## 关于v8性能提升所做的优化

- 将代码转换成字节码，再由字节码转换成机器码

  以前代码是直接转换成机器码的，但是直接转换会有两个问题：一是缓存问题，每次执行相同的代码都要转换一次机器码，若是将机器码存储起来非常占用内存（存的是二进制文件）；二是因为惰性编译的原则，以前代码编写多采用闭包形式，若采用立即调用函数方式就会导致部分代码不会被缓存。因此改成了字节码。

  - 什么是惰性编译

    ```
    function foo(){
    	console.log('hello world!')
    }
    var temp = 1
    var test = 2
    foo()
    ```

    上述代码在编译过程中只会编译temp和test，只有调用foo的时候才会去编译foo函数

- 快属性慢属性

  原本的属性都是存储在elements和properties里，所以调用都会多加一层，后来将少数常规属性直接存储到对象本身就可加快查找的速率

- 隐藏类

  v8会为每个对象创建隐藏类，对象中的map属性指向了隐藏类。隐藏类中包含所有属性以及属性相对于对象的地址偏移量，这样在查找属性时会更快。当两个类属性和顺序都相同时会复用隐藏类。但当修改对象属性（增加、删除）就会重构隐藏类。

  当函数内部调用其他对象或函数中的某个属性时使用隐藏类查找的过程就会非常繁琐（先查找对象的隐藏类，再找到属性），v8会做一个缓存处理，也就是反馈向量。

- 垃圾回收机制

  最开始的垃圾回收机制会完整的在主线程上执行，但这种方式会造成主线程卡顿。v8给出的优化方案有三种：一是采用多个辅助线程并行执行回收，二是将工作分成小块，穿插在主线程不同任务之间，三是辅助线程并发回收。

  - 并行并发的区别：

    并行：同一时刻同时执行，并发：同一时间间隔交替执行



## 关于闭包中变量的内存泄露问题

由于惰性解析，闭包函数并不会被立即解析，因此我们无法知道这个函数内部是否引用了外部的变量，也就不知道是否该在销毁执行上下文弹栈前把变量存储。V8为解决这个问题，采用预解析的方法，即使不对函数编译运行，也会对其进行解析，看函数内部是否存在语法错误以及是否引用了外部变量。

为什么闭包的变量会存在内存泄露的问题？由于预解析机制，闭包引用的变量会储存在栈之中，且只会被闭包引用。这就导致了一个问题：即使外部函数执行完毕，内存中仍然会保留对这些变量的引用，无法被垃圾回收器回收，从而造成内存泄露。