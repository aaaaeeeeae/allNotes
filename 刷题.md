## 刷题

### 剑指59 队列最大值

请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数`max_value`、`push_back` 和 `pop_front` 的均摊时间复杂度都是O(1)。若队列为空，`pop_front` 和 `max_value` 需要返回 -1

- 核心思路：维护两个数组，一个是普通的队列，负责做push、pop基础操作。另一个是最大值类队列。当执行push操作时，维护中第一个元素使其最大，若最大值队列中顶层元素比push的元素小就循环pop，否则push。当执行pop操作时，只要保证pop出的元素不是最大值队列的首个元素就行，如果是最大值队列的首个元素，也需要将其出队。其他操作都是队列基本操作。
- 遇到的一些问题：

  - 在进行pop操作时，若pop出的元素刚好时最大值队列中首个元素（最大元素），最大元素出队了，队列中后一个元素可能并不是最大的，若此时执行 max_value 操作不会出错吗？想象这样一个场景：先执行push操作，并且当前push的元素大于最大值队列中所有元素，因此最大值队列会被清空后再将push的元素入队。而后执行pop操作，那么这个元素会因为pop被弹出了，此时再执行maxValue操作，就会输出-1，但实际上最大元素肯定不是-1
  - 其实这道题的最大值队列并不是队列，有点类似于栈的思想，我最开始想的是队列就会出现上述描述场景的错误，但如果是栈的话就没问题了。但紧接着如果是栈的话那为什么取max_value时取的是第一个元素而不是顶层值呢？这是因为栈中没必要存储对结果没影响的元素，也就是说维护的栈是一个降序排列的数组，当push值比栈顶元素小时，说明push值比栈中所有元素都小，直接push；当比其大时，循环pop，维护加入元素后的降序数组。



### 剑指48 最长不含重复字符的子字符串

请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

- 核心思路：
  - 使用滑动窗口的方式，维护一个滑动窗口（数组），当没有重复字符出现的时候将其push入数组，当有出现重复字符时，使用 shift 依次循环弹出。
  - 采用动态规划，dp 数组中每一位表示到目前为止不重复子串长度，其状态转移方程为：当 i < 0 时（从0到 j 没有重复的字符），dp[j] = dp[j-1]+1，当 i >= 0 时 dp[j] = j - i，当然这种计算方式时间复杂度会很大，优化的话采取哈希表的方式把元素存储进去。



### 剑指46 把数字翻译成字符串

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

- 核心思路：
  - 典中典动态规划。一样的套路，先确定dp数组代表的含义。很显然，dp[i] 表示的是到 i 为止有多少种翻译方法。最开始状态转移方程我想的是这样：当 i 和 i - 1组合时数字小于等于 25（能够组合），那么 dp[i] = dp[i - 1] + 1，不能组合则 dp[i] = dp[i -1]。我这样是忽视了 i - 2 状态对当前的影响，因为最多只能两个数字组合在一起，所以当前状态于上一个和上上一个字符有关，真正的状态转移方程应该是当 i - 1和 i - 2 能够组成字符时，dp[i] = dp[i-1] + dp[i-2]，否则 dp[i] = dp[i - 1]
  
    

### 力扣49 字母异位词分组

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

- 核心思路：

  - hashMap经典应用。存储每个单词有的字符数，如果map中存在同样的字符数说明两个单词为异位词。

    - 疑问：count 是 26 个字符数组，数组是引用数据类型，使用 map[count] 即便 count 数组值是一样的，也会不相等吧？

      由于 JavaScript 中对象的键只能是字符串类型，当使用一个引用数据类型（如数组）作为键时， JavaScript 会将其自动转换为字符串。
      



### 力扣128 最长连续序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

- 核心思路
  - 方法挺多的，最简单的方法应该是将其排序，然后找下一个是否是上一个数+1（连续），但时间复杂度要为O(n)。一个非常巧妙的方式是用一个map存储相邻位置能提供的连续长度，让左边+右边+1就是连续序列的长度。当然也要对map进行更新，除了更新当前值以外，还要更新num-preNum和num+nextNum的数值。
    - 为什么要更新num-preNum和num+nextNum？
      - 不知道，没看懂

### 力扣 接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

- 核心思路
  - 这道题可以用双指针来完成。首先需要搞清楚如何计算接的雨水的量？应该以列为单位来看，能接的雨水量应该是min(left, right) - height(i)，因此我们需要找到当前列左边最高柱子和右边最高柱子，两者取最小。用两个数组记录左右最大柱子高度，再依次遍历 i ，用上述公式计算加和即可。



### 力扣438 找到字符串中所有的字母异位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

- 核心思路
  - 滑动窗口经典应用。最开始我的思路是用一个数组存储p中的字符，然后在s中用滑动窗口遍历。但这么做没考虑到相同字符的情况。正确的做法应该是对象记录p中的字符，key为字母，value为出现次数，并存储p中不同字符的个数，让滑动窗口初始化为对象，把出现过的字符放入滑动窗口中并初始化为0。遍历s是，如果是char在滑动窗口内的字符，对应字符值++，若个数也相等则新的不同字符数++，直到不同字符数与p中不同字符数相等。



### 力扣560 和为K的子数组

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的连续子数组的个数* 。

```
输入：nums = [1,1,1], k = 2
输出：2
```

- 核心思路

  - 最开始我的思路是队列的思想（滑动窗口），依次将nums加入队列中并计算和，若和与k相等则ans++，和比k大就出队重新计算和。当nums全入队之后只进行出队的操作。但这个用例[-1, -1, 1] 0 把我干懵了。因为只能把sum初始值设为0，就会比正确值多一。

  - 采用前缀和+哈希表顺利解决。哈希表记录每次前缀和的结果并将其设置为key，value为出现次数，初始化 hashMap 中 0 为 1（prefix直接等于k的情况）。在哈希表中查找 prefix - k 的值，让ans += 这个值
  - 为什么是ans += hashMap[prefix - k] ？最开始我以为这个的含义是 prefix - k = 0，即相等。但其实prefix - k可以等于其他出现并记录在其中的键的值，因为map中的key都可以被数组中任意数加和起来，value为数组中任意组合值为key的次数



### 力扣41 缺失的第一个正数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

```
输入：nums = [1,2,0]
输出：3
```

- 核心思路

  - 这道题的关键要点是想明白最终答案的范围只可能是[1, N+1]，N为数组的长度。
    - 当数组中所有数的值都大于数组长度N时，最小的为1
    - 当数组中所有数的值都小于等于数组长度N时，最小为N+1
    - 当数组中所有数都小于等于0时，最小的为1
    - 当数组中值在该范围内，最小的也在范围内

  - 需要一个map存储1到N+1中的所有数并将值设置为1（设置为0后续遍历map会出现判断问题），遍历传入的数组，如果值为1到N+1中的数时，将map中的值+1，当值小于等于0或大于N+1，不处理。随后遍历map中的值，找第一个为1的即可。



### 力扣21 合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

- 核心思路
  - 这个题用双指针可以轻松解决，但比较难想的是递归的写法。写递归应该先写递归出口，什么时候到出口？肯定是递归到两个链表中其中一个（或同时）为尾节点时。什么时候递归？当 l1.val < l2.val 时就应该让 l1 的节点插入答案中，因此递归时返回 l1 并且传入参数为l1.next  l2，同理，l1.val >= l2.val 时，返回 l2 传入 l1  l2.next
  
    

力扣19 删除链表的倒数第 N 个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

- 核心思路
  - 这道题我原本的思路是遍历一次链表找到长度，然后再找倒数第n+1个节点。但需要考虑以下几个问题：n+1 > len：表示n = len，即删除头节点，head = head.next；n + 1 = 1：表示删除尾节点，cur.next = null；其他情况都是cur.next = cur.next.next。
  
  - 但很显然这种方法耗时非常长。应当采用快慢指针的方式最佳。先让快指针走n步，然后让快指针和慢指针一起走，当快指针走到倒数第二个节点时，让slow.next = slow.next.next。但仍需要注意头节点（fast为null）让其返回head.next即可。
    - 这里为什么是倒数第二个节点？如果是最后一个节点，那么slow.next.next会报错，而且我们也不需要得到最后一个节点，即便要删除的是最后一个节点，当slow为倒数第二个节点时slow.next.next为null刚好
    
      

力扣139 单词拆分

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

- 核心思路
  - 使用动态规划。这个题能想到使用动态规划感觉还挺难的，要写动规就得现确定dp数组代表的含义，这里dp[i]表示的含义是到i为止的子串是否能由字典构成。随后是状态转移方程：若dp[i] = true，且i到j的字母在字典中，那么dp[j] = true
  
    

力扣236 二叉树最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

- 核心思路
  - 这道题主要是关于树的递归。其实这个题只有三种情况，一是当前节点左子树为p、右子树为q，那么公共祖先就是root；二是当前节点就为p或者q，那么公共祖先一定是当前节点及上面的节点；三是其他情况，则继续进行递归左右子树。若当前节点为null则表明已经到达叶节点，也就是递归的终点。
